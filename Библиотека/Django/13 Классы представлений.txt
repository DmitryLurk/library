CBV - class based views

Лучшей практикой считается создание представлений на основе классов
Разберем отображение главной страницы на примере класса который генерирует список

from django.views.generic import ListView

по умолчанию данный класс будет искать html страницу куда это отображать по адресу имяприложения/имямодели_list.html
если у нас уже есть html файл который используется для отображения этой функции и он размещен не там где подразумевается по умолчанию^ 
то в классе необходимо прописать строчку template_name

class WomenHome(ListView):
    model = Women
    template_name = 'women/index.html'
    context_object_name = 'posts'	по умолчанию обьект по которому будет проходится итератор в html странице бедт называться object_list
					если необходимо переопределить это значения то переопределяется данный атрибут
    extra_context = {'title': 'Главная страница'} Дополнительные данные которые мы должны передать

    def get_context_data(self, *, object_list=None, **kwargs): Для того  чтобы переадть и динамический и статический контекст формируется специальная функция
        context = super().get_context_data(**kwargs)		Обращаемся к базовому классу и берем весь контекст чтобы это не затереть 
        context["menu"] = menu					А затем добавляем в переменную необходимые данные (в данном случае глобальную переменную menu)
        return context
    def get_queryset(self):
        """
            Функция возвращает данные таблицы отфильтрованные по флагу публикации
        """
        return Women.objects.filter(is_published=True)

справка: как выглядит html код
  {% for p in posts %}
  <li>
    <div clas..........
	
В urls.py обязательно необходимо прописать путь 
urlpatterns = [
    path("", WomenHome.as_view(), name="home"), где .as_view() обязательно со скобками тк мы там эту функцию вызываем